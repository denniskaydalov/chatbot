import java.util.ArrayList;
import java.util.List;
import java.time.format.DateTimeFormatter;  
import java.time.LocalDateTime;
import java.lang.Math;

/**
 * This enum defines the behaviour of the ResponseType enum, which is used to identify response types in parsing.
 * 
 * @author Dennis Kaydalov
 * 
 * @version November 8, 2022
 */
enum ResponseType {
    USER_VALUE_MODIFIER,
    NEUTRAL_VALUE_MODIFIER,
    HOST_VALUE_MODIFIER,
    USER_VALUE_REQUEST,
    NEUTRAL_VALUE_REQUEST,
    HOST_VALUE_REQUEST,
    TERMINATE,
    PLAIN_TEXT;
}

/**
 * This class defines the behaviour of the Parser class, which is used to parser an ArrayList of tokens into a final response.
 * 
 * @author Dennis Kaydalov
 * 
 * @version November 8, 2022
 */
public class Parser {
    private ArrayList<TokenMatch> matchesList;

    /**
     * Parameterized constructor to initialize the matchesList ArrayList
     * 
     * @param matchesList The list of matches generated by the Lexer
     * @see TokenMatch 
     * @see Lexer
     */
    public Parser(ArrayList<TokenMatch> matchesList) {
        this.matchesList = matchesList;
    }

    /**
     * This method accepts nothing because it uses the private matchesList variable assigned in the constructor, and constructs a response based off of the tokens
     * 
     * @return ResponseData - The response in ResponseData format
     * @see ResponseData 
     */
    public ResponseData parseTokens() {
        ArrayList<ResponseData> responses = new ArrayList<ResponseData>();
        // Iterate through tokens.
        for(int i = 0; i < matchesList.size(); ++i) {
            // Switch statement cheking the token type, and formatting a response.
            switch(matchesList.get(i).tokenType) {
                case GREETING:
                    return new ResponseData(ResponseType.PLAIN_TEXT, greeting());
                case TERMINATE:
                    return new ResponseData(ResponseType.TERMINATE, "BYE;" + farewell());
                case REQUEST_INITIALIZER:
                    try {
                        if(matchesList.get(i+1).value.matches(".*my.*")) {
                            return new ResponseData(ResponseType.USER_VALUE_REQUEST, "", matchesList.get(i+2).value, ""); 
                        }
                        else if(matchesList.get(i+1).value.matches(".*(the|a).*")) {
                            if(matchesList.get(i+2).value.equals("joke")) return new ResponseData(ResponseType.PLAIN_TEXT, joke());
                            if(matchesList.get(i+2).value.equals("time")) return new ResponseData(ResponseType.PLAIN_TEXT, time());
                            return new ResponseData(ResponseType.NEUTRAL_VALUE_REQUEST, "", matchesList.get(i+2).value, "");
                        }
                        else {
                            return new ResponseData(ResponseType.HOST_VALUE_REQUEST, "", matchesList.get(i+2).value, ""); 
                        }
                    }
                    catch (Exception e) {
                        return new ResponseData(ResponseType.PLAIN_TEXT, "Sorry, I can\'t quite understand what you\'re trying to say there.");
                    }
                case POSSESSIVE:
                    try {
                        if(matchesList.get(i).value.matches(".*my.*")) {
                            return new ResponseData(ResponseType.USER_VALUE_MODIFIER, "Cool!", matchesList.get(i+1).value, matchesList.get(i+3).value);
                        }
                        else if(matchesList.get(i).value.matches(".*(the|a).*")) {
                            return new ResponseData(ResponseType.NEUTRAL_VALUE_MODIFIER, "Alright!", matchesList.get(i+1).value, matchesList.get(i+3).value);
                        }
                        else {
                            return new ResponseData(ResponseType.HOST_VALUE_MODIFIER, "OK!", matchesList.get(i+1).value, matchesList.get(i+3).value);
                        }
                    }
                    catch (Exception e) {
                        return new ResponseData(ResponseType.PLAIN_TEXT, "Sorry, I can\'t quite understand what you\'re trying to say there.");
                    }
            }
        }
        return new ResponseData(ResponseType.PLAIN_TEXT, "Sorry, I can\'t quite understand what you\'re trying to say there.");
    }
    
    /**
     * This method returns a random greeting
     * 
     * @return String - A random response String
     */
    private String greeting() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("HH");  
        LocalDateTime now = LocalDateTime.now();  
        int hour = Integer.parseInt(dtf.format(now));
        String option = randomOption(new String[] {"Hi!", "Hello!", "Long time no see!", "Yo!", "Good", "Howdy!"});
        if(option.equals("Good")) {
            if(hour < 12 && hour >= 5) { 
                return "Good morning!";
            }
            if(hour >= 12 && hour < 18) { 
                return "Good afternoon!";
            }
            if (hour >= 18 && hour < 24){
                return "Good evening!";
            }
            else {
                return "Good morning? What are you doing up at this hour?!";
            }
        }
        else {
            return option;
        }
    }

    /**
     * This method returns a random farewell
     * 
     * @return String - A random farewell String
     */
    private String farewell() {
        return randomOption(new String[] {"Farewell!", "Goodbye then!", "See you later!", "Buh-bye now!", ":(", "Later!", "Cya!", "Adios!", "I guess I'll cry by myself now...", "\'bout time.", "Cheerio!", "Ciao!", "Au revoir!", "Bye-bye!", "Goodbye then.", "Later!", "Bye... for now.", "Peace!", "Take care!", "Fare thee well!", "Don\'t get run over!", "K"});
    }

    /**
     * This method returns a random joke 
     * 
     * @return String - A random joke String
     */
    private String joke() {
        return randomOption(new String[] {"I\'m afraid for the calendar. Its days are numbered.", "\"What do you call a fish wearing a bowtie?\" \"Sofishticated.\"", "Have you heard about the chocolate record player? It sounds pretty sweet.", "I only know 25 letters of the alphabet. I don't know y.", "I asked my dog what's two minus two. He said nothing.", "\"What does a sprinter eat before a race?\" \"Nothing, they fast!\"", "I don't trust those trees. They seem kind of shady.", "Why don\'t eggs tell jokes? They'd crack each other up."});
    }

    /**
     * This method returns the time
     * 
     * @return String - The time
     */
    private String time() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();
        return(dtf.format(now));
    }

    /**
     * This method returns a random String from an array of Strings
     * 
     * @param String[] The array of Strings to pick a random String from
     * @return String - The random String
     */
    private String randomOption(String[] options) {
        return options[(int)(Math.random()*options.length)];
    }
}
